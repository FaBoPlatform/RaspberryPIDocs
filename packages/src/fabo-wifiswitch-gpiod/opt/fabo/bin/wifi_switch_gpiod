#!/usr/bin/python
# coding: utf-8
# /opt/fabo/bin/wifi_switch_gpiod
# pip install futures

import time
from concurrent import futures
import os
import multiprocessing
import RPi.GPIO as GPIO
import thread
import threading
import logging
from multiprocessing.managers import SyncManager

# ログ設定
logging.basicConfig(level=logging.DEBUG,
                    format='[%(levelname)s] time:%(created).8f pid:%(process)d pn:%(processName)-10s tid:%(thread)d tn:%(threadName)-10s fn:%(funcName)-10s %(message)s',
)


class FaboGPIO():
    #ジャンパピン
    N_REST = 24
    #スライドスイッチでモード選択
    DHCP_PIN = 25
    AP_PIN = 26
#

class Pulse_Work_Thread(threading.Thread):

    def __init__(self, group=None, target=None, name=None,
                 args=(), kwargs=None, verbose=None):
        threading.Thread.__init__(self, group=group, target=target, name=name,
                                  verbose=verbose)
        self.lock = threading.Lock()
        self.set_wait_time(args)
        self.GPIO_NO = kwargs[0]
        return

    def set_wait_time(self, wait_time):
        logging.debug('Waiting for lock')
        with self.lock:
            self.wait_time = wait_time
            # スレッド実行中ならend_timeを延長する
            if self.isAlive():
                self.end_time = time.time() + wait_time
        return
    def get_end_time(self):
        with self.lock:
            return self.end_time
    def run(self):
        logging.debug("---------- pulse start ----------")
        # 処理開始時のGPIO_NOを記録する
        _START_VALUE = GPIO.input(self.GPIO_NO) # 反応したピン。メイン反応はこれ
        _START_VALUE1 = GPIO.input(FaboGPIO.N_REST)
        _START_VALUE2 = GPIO.input(FaboGPIO.DHCP_PIN)
        _START_VALUE3 = GPIO.input(FaboGPIO.AP_PIN)

        ########################################
        # パルス安定待ち
        ########################################
        # スレッド開始時にend_timeを設定する
        self.end_time = time.time() + self.wait_time
        while self.get_end_time() >= time.time():
            logging.debug('waiting')
            time.sleep(0.5)
        logging.debug("---------- pulse end ----------")
        ########################################
        # パルス安定 処理開始
        ########################################
        while True:
            _START2_VALUE1 = GPIO.input(FaboGPIO.N_REST)
            _START2_VALUE2 = GPIO.input(FaboGPIO.DHCP_PIN)
            _START2_VALUE3 = GPIO.input(FaboGPIO.AP_PIN)
            logging.debug("---------- switch start ----------")
            if _START2_VALUE1 == 1:
                os.system('/opt/fabo/bin/wifi_switch --print-config > /opt/fabo/conf/wifi_switch.conf')
            if _START2_VALUE2 == 1:
                os.system('/opt/fabo/bin/wifi_switch --mode dhcp')
            elif _START2_VALUE3 == 1:
                os.system('/opt/fabo/bin/wifi_switch --mode ap')
            else:
                logging.debug('nothing')

            logging.debug("---------- switch end ----------")
            _END_VALUE = GPIO.input(self.GPIO_NO)
            _END_VALUE1 = GPIO.input(FaboGPIO.N_REST)
            _END_VALUE2 = GPIO.input(FaboGPIO.DHCP_PIN)
            _END_VALUE3 = GPIO.input(FaboGPIO.AP_PIN)


            if (not _START2_VALUE1 == _END_VALUE1) or (not _START2_VALUE2 == _END_VALUE2) or (not _START2_VALUE3 == _END_VALUE3):
                # 処理前後でスイッチ値が不一致なのでリトライする
                logging.debug("retry")
            else:
                logging.debug(str(FaboGPIO.N_REST)+":"+str(_END_VALUE1)+" "+str(FaboGPIO.DHCP_PIN)+":"+str(_END_VALUE2)+" "+str(FaboGPIO.AP_PIN)+":"+str(_END_VALUE3))
                break
        #


        logging.debug('end')
        return
#


'''
信号がブレるのでwifi_switch関係の3pinのどれかに反応したら、3pinをすべての状態を確認する
引数のGPIO_NOなんて飾りです。偉い人にはそれが判るのです
パルスイベント発生後、pulse_wait_time秒待って走査する
パルスイベントがある程度キャッシュされることがあるため、sleepは別スレッドで行うことにより、パルスイベントがスムーズに流れるようにしておく
'''
def wifi_switch_callback(GPIO_NO):
    tag='wifi_switch_callback'
    logging.debug(tag)

    # パルス安定待ち時間sec
    pulse_wait_time=2.0
    if not 'pulse_work_thread' in globals():
        global pulse_work_thread
        pulse_work_thread = Pulse_Work_Thread(kwargs=[GPIO_NO])

    if not pulse_work_thread.isAlive():
        logging.debug("t cleate")
        pulse_work_thread = Pulse_Work_Thread(kwargs=[GPIO_NO])
        pulse_work_thread.set_wait_time(pulse_wait_time)
        pulse_work_thread.start()
    else:
        logging.debug("t Alive")
        pulse_work_thread.set_wait_time(pulse_wait_time)
    #

    return
#

'''
ここはプロセスで実行される
SHARED_VARIABLE['PROCESS_WIFI_SWITCH']=True であるうちは実行を続ける
'''
def process_wifi_switch(SHARED_VARIABLE):
    tag='process_wifi_switch'
    logging.debug("enter "+tag)

    SHARED_VARIABLE['PROCESS_WIFI_SWITCH']=True
    
    # GPIO指定をFaboGPIOで行う
    GPIO.setmode(GPIO.BCM)   # GPIO番号指定
    GPIO.setup(FaboGPIO.N_REST, GPIO.IN)
    GPIO.setup(FaboGPIO.DHCP_PIN, GPIO.IN)
    GPIO.setup(FaboGPIO.AP_PIN, GPIO.IN)

    # エッジ検出イベントの取得
    # イベントの通知登録
    # 激打すると稀にオンオンやオフオフとなることがあるが、おそらくイベント検出がスキップされている
    GPIO.add_event_detect(FaboGPIO.N_REST, GPIO.RISING, callback=wifi_switch_callback, bouncetime=500)
    GPIO.add_event_detect(FaboGPIO.DHCP_PIN, GPIO.RISING, callback=wifi_switch_callback, bouncetime=50)
    GPIO.add_event_detect(FaboGPIO.AP_PIN, GPIO.RISING, callback=wifi_switch_callback, bouncetime=50)


    while SHARED_VARIABLE['PROCESS_WIFI_SWITCH']:
        #logging.debug("waiting for end")
        time.sleep(1e+6) # コールバックは別スレッドで実行されるため、メインスレッドを終わらせないようにする。


    # イベント検知の解除
    GPIO.remove_event_detect(FaboGPIO.N_REST)
    GPIO.remove_event_detect(FaboGPIO.DHCP_PIN)
    GPIO.remove_event_detect(FaboGPIO.AP_PIN)
    # 終了処理
    GPIO.cleanup(FaboGPIO.N_REST)
    GPIO.cleanup(FaboGPIO.DHCP_PIN)
    GPIO.cleanup(FaboGPIO.AP_PIN)
    return


'''
プロセスによる実行関数の振り分け定義
'''
PROCESS_LIST=['process_wifi_switch']
def do_process(target, SHARED_VARIABLE):

    if target == 'process_wifi_switch':
        process_wifi_switch(SHARED_VARIABLE)
        return "end process_wifi_switch"

def Manager():
    m = SyncManager()
    m.start()
    return m
'''
process pattern
'''
mg = Manager()
SHARED_VARIABLE=dict()
SHARED_VARIABLE['PROCESS_WIFI_SWITCH']=False


'''
起動時にスイッチ状態を反映するために、一度実行する
'''
# GPIO指定をFaboGPIOで行う
GPIO.setmode(GPIO.BCM)   # GPIO番号指定
GPIO.setup(FaboGPIO.N_REST, GPIO.IN)
GPIO.setup(FaboGPIO.DHCP_PIN, GPIO.IN)
GPIO.setup(FaboGPIO.AP_PIN, GPIO.IN)
logging.debug("---------- switch start ----------")
if GPIO.input(FaboGPIO.N_REST) == 1:
    os.system('/opt/fabo/bin/wifi_switch --print-config > /opt/fabo/conf/wifi_switch.conf')
if GPIO.input(FaboGPIO.DHCP_PIN) == 1:
    os.system('/opt/fabo/bin/wifi_switch --mode dhcp')
elif GPIO.input(FaboGPIO.AP_PIN) == 1:
    os.system('/opt/fabo/bin/wifi_switch --mode ap')
else:
    logging.debug('nothing')
logging.debug("---------- switch end ----------")
# 終了処理
GPIO.cleanup(FaboGPIO.N_REST)
GPIO.cleanup(FaboGPIO.DHCP_PIN)
GPIO.cleanup(FaboGPIO.AP_PIN)


'''
メイン処理を行う部分
・メインスレッド（ここ）
・スレッド1(concurrent.futures) - 
・スレッド2(concurrent.futures) - 無し
・制御スレッド(concurrent.futures) - 無し
'''
def do_main():

    try:
        with futures.ProcessPoolExecutor(max_workers=len(PROCESS_LIST)) as executer:
            mappings = {executer.submit(do_process, pname, SHARED_VARIABLE): pname for pname in PROCESS_LIST}
            for i in futures.as_completed(mappings):
                target = mappings[i]
                result = i.result()
                logging.debug(result)

    except Exception as e:
        logging.debug('error! executer failed.')
        logging.debug(str(e))
    finally:
        logging.debug("executer end")

    return


logging.debug("this is main")

do_main()

